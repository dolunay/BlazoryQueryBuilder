@using System.Linq.Expressions
@using Microsoft.EntityFrameworkCore
@using MudBlazor
@using System.Reflection

<MudSelect T="ExpressionOperator" Label="Operator" Value="Operator" ValueChanged="OperatorChanged" ToStringFunc="SelectedOperatorToString">
    @foreach (var item in Operators)
    {
        <MudSelectItem Value="@item">@item.DisplayText</MudSelectItem>
    }
</MudSelect>

@code {
    List<ExpressionOperator> Operators = new();

    [Parameter]
    public Action<ExpressionOperator> OnChange { get; set; }

    [Parameter]
    public ExpressionOperator Operator { get; set; }

    private void OperatorChanged(ExpressionOperator op)
    {
        Operator = op;
        OnChange?.Invoke(op);
    }

    private string SelectedOperatorToString(ExpressionOperator op)
    {
        return op != null 
            ? Operators.Single(o => o == op).DisplayText
            : string.Empty;
    }

    // TODO: Verify that this method is needed for MethodOperator
    private string SelectedOperatorToString(MethodCallOperator op)
    {
        return op != null
            ? Operators.Single(o => o == op).DisplayText
            : string.Empty;
    }

    [Parameter]
    public Type OperandType { get; set; }

    protected override void OnInitialized()
    {
        Operators = GetOperators(OperandType);

        if (Operator is MethodCallOperator methodOperator)
        {
            Operator = Operators
                .OfType<MethodCallOperator>()
                .FirstOrDefault(op => op == methodOperator);
        }
        else
        {
            Operator = Operators.FirstOrDefault(x => x == Operator);
        }
    }

    public void SetOperand(Type operandType)
    {
        OperandType = operandType;
        Operators = GetOperators(operandType);
        Operator = Operators.First();
    }

    public static List<ExpressionOperator> GetOperators(Type operandType)
    {
        return operandType switch
        {
            Type type when type == typeof(int) => new()
            {
                { new EqualsOperator() },
                { new NotEqualsOperator() },
                { new LessThanOperator() },
                { new LessThanOrEqualOperator() },
                { new GreaterThanOperator() },
                { new GreaterThanOrEqualOperator() },
            },
            Type type when type == typeof(string) => new()
            {
                { new EqualsOperator() },
                { new NotEqualsOperator() },
                { new EfLikeOperator() },
                { new EfLikeOperator(true) },
            },
            Type type when type == typeof(bool) => new()
            {
                { new EqualsOperator() },
                { new NotEqualsOperator() },
            },
            Type type when type == typeof(DateTime) => new()
            {
                { new EqualsOperator() },
                { new NotEqualsOperator() },
                { new LessThanOperator() },
                { new LessThanOrEqualOperator() },
                { new GreaterThanOperator() },
                { new GreaterThanOrEqualOperator() },
            },
            _ => new()
            {
                { new EqualsOperator() },
                { new NotEqualsOperator() },
            },
        };
    }

    public class ExpressionOperator
    {
        public virtual ExpressionType ExpressionType { get; set; }
        public virtual string DisplayText { get; set; }

        public override bool Equals(object obj)
        {
            return obj is ExpressionOperator op 
                && ExpressionType == op.ExpressionType;
        }

        public override int GetHashCode()
        {
            return HashCode.Combine(ExpressionType);
        }

        public static bool operator ==(ExpressionOperator left, ExpressionOperator right)
        {
            return EqualityComparer<ExpressionOperator>.Default.Equals(left, right);
        }

        public static bool operator !=(ExpressionOperator left, ExpressionOperator right)
        {
            return !(left == right);
        }
    }

    public class EqualsOperator : ExpressionOperator
    {
        public override ExpressionType ExpressionType => ExpressionType.Equal;
        public override string DisplayText => "Equals";
    }

    public class NotEqualsOperator : ExpressionOperator
    {
        public override ExpressionType ExpressionType => ExpressionType.NotEqual;
        public override string DisplayText => "Does not equal";
    }

    public class LessThanOperator : ExpressionOperator
    {
        public override ExpressionType ExpressionType => ExpressionType.LessThan;
        public override string DisplayText => "Less than";
    }

    public class LessThanOrEqualOperator : ExpressionOperator
    {
        public override ExpressionType ExpressionType => ExpressionType.LessThanOrEqual;
        public override string DisplayText => "Less than or equal";
    }

    public class GreaterThanOperator : ExpressionOperator
    {
        public override ExpressionType ExpressionType => ExpressionType.GreaterThan;
        public override string DisplayText => "Greater than";
    }

    public class GreaterThanOrEqualOperator : ExpressionOperator
    {
        public override ExpressionType ExpressionType => ExpressionType.GreaterThanOrEqual;
        public override string DisplayText => "Greater than or equal";
    }

    public class MethodCallOperator : ExpressionOperator
    {
        public override ExpressionType ExpressionType => ExpressionType.Call;
        public MethodInfo MethodInfo { get; set; }
        public bool IsNegated { get; set; }

        public MethodCallOperator(MethodInfo methodInfo, bool isNegated = false)
        {
            MethodInfo = methodInfo;
            IsNegated = isNegated;
        }

        public override bool Equals(object obj)
        {
            return obj is MethodCallOperator op 
                && base.Equals(obj) 
                && EqualityComparer<MethodInfo>.Default.Equals(MethodInfo, op.MethodInfo) 
                && IsNegated == op.IsNegated;
        }

        public override int GetHashCode()
        {
            return HashCode.Combine(base.GetHashCode(), MethodInfo, IsNegated);
        }

        public static bool operator ==(MethodCallOperator left, MethodCallOperator right)
        {
            return EqualityComparer<MethodCallOperator>.Default.Equals(left, right);
        }

        public static bool operator !=(MethodCallOperator left, MethodCallOperator right)
        {
            return !(left == right);
        }
    }

    public class EfLikeOperator : MethodCallOperator
    {
        public override string DisplayText => "Like";

        public EfLikeOperator(bool isNegated = false)
            : base(typeof(DbFunctionsExtensions).GetMethod("Like", new[] { typeof(DbFunctions), typeof(string), typeof(string) }), isNegated)
        {
        }
    }
}