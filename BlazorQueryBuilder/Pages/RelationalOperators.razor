@using System.Linq.Expressions
@using BlazorQueryBuilder.ExpressionVisitors.Extensions
@using BlazoryQueryBuilder.Shared.Extensions
@using Microsoft.EntityFrameworkCore
@using MudBlazor
@using System.Reflection

<MudSelect T="ExpressionOperator" Label="Operator" Value="_operator" ValueChanged="OperatorChanged" ToStringFunc="SelectedOperatorToString">
    @foreach (var item in _operators)
    {
        <MudSelectItem Value="@item">@item.DisplayText</MudSelectItem>
    }
</MudSelect>

@code {
    [Parameter]
    public Expression PredicateExpression { get; set; }

    [Parameter]
    public Action<Expression> OnChange { get; set; }

    private ExpressionOperator _operator { get; set; }
    private List<ExpressionOperator> _operators = new();
    private Expression _valueExpression;
    private MemberExpression _memberAccessExpression;

    protected override void OnInitialized()
    {
        InitializeOperators();
    }

    private void InitializeOperators()
    {
        if (PredicateExpression is BinaryExpression binaryExpression)
        {
            InitializeBinaryExpression(binaryExpression);
        }
        else if (PredicateExpression is MethodCallExpression methodCallExpression)
        {
            InitializeMethodCallExpression(methodCallExpression);
        }
        else if (PredicateExpression is UnaryExpression unaryExpression
            && unaryExpression.NodeType == ExpressionType.Not
            && unaryExpression.Operand is MethodCallExpression notMethodCallExpression)
        {
            InitializeMethodCallExpression(notMethodCallExpression, true);
        }
        else 
        {
            throw new NotSupportedException($"Expression type {PredicateExpression.NodeType} is not supported");
        }
    }

    private void InitializeBinaryExpression(BinaryExpression binaryExpression)
    {
        _operators = GetOperators(binaryExpression.Left.Type);
        _operator = _operators.FirstOrDefault(o => o.ExpressionType == binaryExpression.NodeType) ?? _operators.First();
        _valueExpression = binaryExpression.Right;
        _memberAccessExpression = (MemberExpression)binaryExpression.Left;
    }

    private void InitializeMethodCallExpression(MethodCallExpression methodCallExpression, bool isNegated = false)
    {
        switch (methodCallExpression.Method.Name)
        {
            case "Like":
                _operators = GetOperators(((MemberExpression)methodCallExpression.Arguments[1]).Type);
                _memberAccessExpression = (MemberExpression)methodCallExpression.Arguments[1];
                _valueExpression = methodCallExpression.Arguments[2];
                break;
            default:
                throw new NotSupportedException($"Method {methodCallExpression.Method.Name} is not supported");
        }

        _operator = _operators
            .OfType<MethodCallOperator>()
            .FirstOrDefault(o =>
                o.ExpressionType == methodCallExpression.NodeType
                && o.MethodInfo == methodCallExpression.Method
                && o.IsNegated == isNegated)
            ?? _operators.First();


    }

    private void OperatorChanged(ExpressionOperator op)
    {
        _operator = op;

        if (op is BinaryOperator)
        {
            var newBinaryExpression = Expression.MakeBinary(op.ExpressionType, _memberAccessExpression, Expression.Constant(_memberAccessExpression.Type.GetDefaultValue()));
            OnChange?.Invoke(newBinaryExpression);
        }

        if (op is MethodCallOperator methodCall)
        {
            // TODO: Unit test Like and Not like
            if (methodCall.MethodInfo.Name == "Like")
            {
                var method = methodCall.MethodInfo;
                var newMethodCallExpression = Expression.Call(null, method, Expression.Constant(EF.Functions), _memberAccessExpression, Expression.Constant(_memberAccessExpression.Type.GetDefaultValue(), _memberAccessExpression.Type));
                OnChange?.Invoke(methodCall.IsNegated ? Expression.Not(newMethodCallExpression) : newMethodCallExpression);
            }
        }
    }

    private string SelectedOperatorToString(ExpressionOperator op)
    {
        return op != null 
            ? _operators.Single(o => o == op).DisplayText
            : string.Empty;
    }

    public void UpdateExpression(Expression predicateExpression)
    {
        PredicateExpression = predicateExpression;
        InitializeOperators();
    }

    public static List<ExpressionOperator> GetOperators(Type operandType)
    {
        return operandType switch
        {
            Type type when type == typeof(int) => new()
            {
                { new EqualsOperator() },
                { new NotEqualsOperator() },
                { new LessThanOperator() },
                { new LessThanOrEqualOperator() },
                { new GreaterThanOperator() },
                { new GreaterThanOrEqualOperator() },
            },
            Type type when type == typeof(string) => new()
            {
                { new EqualsOperator() },
                { new NotEqualsOperator() },
                { new EfLikeOperator() },
                { new EfLikeOperator(true) },
            },
            Type type when type == typeof(bool) => new()
            {
                { new EqualsOperator() },
                { new NotEqualsOperator() },
            },
            Type type when type == typeof(DateTime) => new()
            {
                { new EqualsOperator() },
                { new NotEqualsOperator() },
                { new LessThanOperator() },
                { new LessThanOrEqualOperator() },
                { new GreaterThanOperator() },
                { new GreaterThanOrEqualOperator() },
            },
            _ => new()
            {
                { new EqualsOperator() },
                { new NotEqualsOperator() },
            },
        };
    }

    public class ExpressionOperator
    {
        public virtual ExpressionType ExpressionType { get; set; }
        public virtual string DisplayText { get; set; }

        public override bool Equals(object obj)
        {
            return obj is ExpressionOperator op 
                && ExpressionType == op.ExpressionType;
        }

        public override int GetHashCode()
        {
            return HashCode.Combine(ExpressionType);
        }

        public static bool operator ==(ExpressionOperator left, ExpressionOperator right)
        {
            return EqualityComparer<ExpressionOperator>.Default.Equals(left, right);
        }

        public static bool operator !=(ExpressionOperator left, ExpressionOperator right)
        {
            return !(left == right);
        }
    }

    public class BinaryOperator : ExpressionOperator { }

    public class EqualsOperator : BinaryOperator
    {
        public override ExpressionType ExpressionType => ExpressionType.Equal;
        public override string DisplayText => "Equals";
    }

    public class NotEqualsOperator : BinaryOperator
    {
        public override ExpressionType ExpressionType => ExpressionType.NotEqual;
        public override string DisplayText => "Does not equal";
    }

    public class LessThanOperator : BinaryOperator
    {
        public override ExpressionType ExpressionType => ExpressionType.LessThan;
        public override string DisplayText => "Less than";
    }

    public class LessThanOrEqualOperator : BinaryOperator
    {
        public override ExpressionType ExpressionType => ExpressionType.LessThanOrEqual;
        public override string DisplayText => "Less than or equal";
    }

    public class GreaterThanOperator : BinaryOperator
    {
        public override ExpressionType ExpressionType => ExpressionType.GreaterThan;
        public override string DisplayText => "Greater than";
    }

    public class GreaterThanOrEqualOperator : BinaryOperator
    {
        public override ExpressionType ExpressionType => ExpressionType.GreaterThanOrEqual;
        public override string DisplayText => "Greater than or equal";
    }

    public class MethodCallOperator : ExpressionOperator
    {
        public override ExpressionType ExpressionType => ExpressionType.Call;
        public MethodInfo MethodInfo { get; set; }
        public bool IsNegated { get; set; }

        public MethodCallOperator(MethodInfo methodInfo, bool isNegated = false)
        {
            MethodInfo = methodInfo;
            IsNegated = isNegated;
        }

        public override bool Equals(object obj)
        {
            return obj is MethodCallOperator op 
                && base.Equals(obj) 
                && EqualityComparer<MethodInfo>.Default.Equals(MethodInfo, op.MethodInfo) 
                && IsNegated == op.IsNegated;
        }

        public override int GetHashCode()
        {
            return HashCode.Combine(base.GetHashCode(), MethodInfo, IsNegated);
        }

        public static bool operator ==(MethodCallOperator left, MethodCallOperator right)
        {
            return EqualityComparer<MethodCallOperator>.Default.Equals(left, right);
        }

        public static bool operator !=(MethodCallOperator left, MethodCallOperator right)
        {
            return !(left == right);
        }
    }

    public class EfLikeOperator : MethodCallOperator
    {
        public override string DisplayText => IsNegated ? "Not like" : "Like";

        public EfLikeOperator(bool isNegated = false)
            : base(typeof(DbFunctionsExtensions).GetMethod("Like", new[] { typeof(DbFunctions), typeof(string), typeof(string) }), isNegated)
        {
        }
    }
}