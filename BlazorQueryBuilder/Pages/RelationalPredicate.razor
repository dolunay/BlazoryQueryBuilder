@using System.Linq.Expressions
@using System.Reflection
@using BlazorQueryBuilder.ExpressionVisitors.Extensions
@using BlazoryQueryBuilder.Shared.Extensions
@using BlazoryQueryBuilder.Shared.Services
@using BlazoryQueryBuilder.Shared.Util
@using static BlazorQueryBuilder.Pages.RelationalOperators

<MudExpansionPanels>
    <MudExpansionPanel Expanded="true">
        <TitleContent>
            <MudStack Row AlignItems="AlignItems.Center">
                <MudChipSet T="string" Color="Color.Tertiary" Variant="Variant.Text" Label="true" AllClosable>
                    @foreach (var path in _navigationPath)
                    {
                        <MudChip Text="@path"></MudChip>
                    }
                </MudChipSet>
                <MudText Typo="Typo.caption">@PredicateExpression.ToString()</MudText>
            </MudStack>
        </TitleContent>
        <ChildContent>
            <MudStack Spacing="2">
                <MudGrid>
                    <MudItem xs="12" sm="4">
                        <RelationalPredicateField ParameterExpression="ParameterExpression"
                                                  PredicateExpression="PredicateExpression"
                                                  OnNavigatePathChanged="OnNavigationPathChanged"
                                                  OnFieldChanged="OnFieldChanged">
                        </RelationalPredicateField>
                    </MudItem>
                    <MudItem xs="12" sm="4">
                        <RelationalOperators @ref="_relationalOperators"
                                             PredicateExpression="PredicateExpression"
                                             OnChange="@OnOperatorChanged">
                        </RelationalOperators>
                    </MudItem>
                    <MudItem xs="12" sm="4">
                        @* TODO: Move to separate component and test *@
                        @if (PredicateExpression is BinaryExpression binaryExpression)
                        {
                            @switch (binaryExpression.Left.Type)
                            {
                                case Type intType when intType == typeof(int) && binaryExpression.Right is ConstantExpression intConstant:
                                    <MudTextField Label="Value" T="int" Value="@((int)intConstant.Value)" ValueChanged="@OnValueChanged" />
                                    break;
                                case Type stringType when stringType == typeof(string) && binaryExpression.Right is ConstantExpression stringConstant:
                                    <MudTextField Label="Value" T="string" Value="@(stringConstant.Value?.ToString())" ValueChanged="@OnValueChanged" />
                                    break;
                                case Type boolType when boolType == typeof(bool) && binaryExpression.Right is ConstantExpression boolConstant:
                                    <MudSelect Label="Value" T="bool" Value="@((bool)boolConstant.Value)" ValueChanged="@OnValueChanged">
                                        <MudSelectItem Value="true">True</MudSelectItem>
                                        <MudSelectItem Value="false">False</MudSelectItem>
                                    </MudSelect>
                                    break;
                                case Type dateTimeType when dateTimeType == typeof(DateTime) && binaryExpression.Right is NewExpression newDateTime:
                                    <MudDatePicker Label="Value" Date="@(new DateTime((long)((ConstantExpression)newDateTime.Arguments[0]).Value))" DateChanged="@OnValueChanged" />
                                    break;
                            }
                        }
                        @if (PredicateExpression is MethodCallExpression methodCallExpression)
                        {

                            if (methodCallExpression.Method.Name == "Like")
                            {
                                @switch (((MemberExpression)methodCallExpression.Arguments[1]).Type)
                                {
                                    case Type intType when intType == typeof(int):
                                        <MudNumericField Label="Value" T="int" Value="@((int)((ConstantExpression)methodCallExpression.Arguments[2]).Value)" ValueChanged="@OnValueChanged" />
                                        break;
                                }
                            }
                            if (methodCallExpression.Method.Name == "Contains")
                            {
                                @switch (((MemberExpression)methodCallExpression.Arguments[1]).Type)
                                {
                                    case Type stringType when stringType == typeof(string):
                                        <MudStack>
                                            <MudStack>
                                                <MudChip T="string" OnClick="@OpenDialog" Size="Size.Small" Text="Add value" Icon="@Icons.Material.Filled.Add" />
                                                <MudChipSet T="string" Size="Size.Small">
                                                    @foreach (var item in ((IEnumerable<string>)((ConstantExpression)methodCallExpression.Arguments[0]).Value))
                                                    {
                                                        <MudChip T="string" Color="Color.Default" Variant="Variant.Text" OnClose="@OnListItemRemoved" Text="@item" />
                                                    }
                                                </MudChipSet>
                                            </MudStack>
                                        </MudStack>
                                        break;
                                }
                            }
                        }

                    </MudItem>
                    <MudItem xs="12" sm="4">
                        <div>
                            <MudStack Row Spacing="2">
                                <MudButton Variant="Variant.Filled" OnClick="@(() => Add(ExpressionType.AndAlso))">And</MudButton>
                                <MudButton Variant="Variant.Filled" OnClick="@(() => Add(ExpressionType.OrElse))">Or</MudButton>
                                <MudIconButton Variant="Variant.Filled" Icon="@Icons.Material.Filled.Delete" OnClick="Remove"></MudIconButton>
                            </MudStack>
                        </div>
                    </MudItem>
                </MudGrid>
            </MudStack>
        </ChildContent>
    </MudExpansionPanel>
</MudExpansionPanels>

<MudDialog @bind-Visible="_showListItemDialog" Options="_listItemDialogOptions">
    <TitleContent>
        <MudText Typo="Typo.h6">
            Add list value
        </MudText>
    </TitleContent>
    <DialogContent>
        <MudTextField Label="Value" T="string" @bind-Text="_listItemInputValue" />
    </DialogContent>
    <DialogActions>
        <MudButton Variant="Variant.Filled" Color="Color.Primary" Class="px-10" OnClick="@OnListItemAdded">Ok</MudButton>
    </DialogActions>
</MudDialog>

@code {
    [Parameter]
    public Action<Expression> OnChange { get; set; }

    [Parameter]
    public Action OnRemove { get; set; }

    [Parameter]
    public ParameterExpression ParameterExpression { get; set; }

    [Parameter]
    public Expression PredicateExpression { get; set; }

    private RelationalOperators _relationalOperators;
    private List<string> _navigationPath = new();

    private string _listItemInputValue;
    private bool _showListItemDialog;
    private DialogOptions _listItemDialogOptions = new DialogOptions { CloseButton = true };

    protected override void OnInitialized()
    {
        _navigationPath.Add(ParameterExpression.Type.Name);

        base.OnInitialized();
    }

    private void OpenDialog()
    {
        _showListItemDialog = true;
    }

    private void OnListItemAdded()
    {
        if (string.IsNullOrWhiteSpace(_listItemInputValue))
        {
            return;
        }

        var items = ((IEnumerable<string>)((ConstantExpression)((MethodCallExpression)PredicateExpression).Arguments[0]).Value).ToList();
        items.Add(_listItemInputValue);
        _showListItemDialog = false;
        _listItemInputValue = string.Empty;
        UpdateValue(items);
    }

    private void OnListItemRemoved(MudChip<string> item)
    {
        var stringArray = ((IEnumerable<string>)((ConstantExpression)((MethodCallExpression)PredicateExpression).Arguments[0]).Value).ToList();
        stringArray.Remove(item.Text);
        UpdateValue(stringArray);
    }

    private void OnNavigationPathChanged(string propertyName)
    {
        _navigationPath.Add(propertyName);
        StateHasChanged();
    }

    private void OnFieldChanged(Expression expression)
    {
        _relationalOperators.UpdateExpression(expression);

        UpdateExpression(expression);
    }

    private void OnValueChanged(int intValue) => UpdateValue(intValue);

    private void OnValueChanged(string stringValue) => UpdateValue(stringValue);

    private void OnValueChanged(bool boolValue) => UpdateValue(boolValue);

    private void OnValueChanged(DateTime? dateTime)
    {
        if (dateTime.HasValue)
        {
            UpdateValue((Expression)DateTimeExpression.New(dateTime.Value));
        }
    }

    private void UpdateValue<T>(T value) => UpdateValue((Expression)Expression.Constant(value, typeof(T)));

    private void UpdateValue(Expression expression)
    {
        // TODO: Unit test
        if (PredicateExpression is BinaryExpression binaryExpression)
        {
            UpdateExpression(binaryExpression.ReplaceRight(expression));
        }
        // TODO: Unit test
        else if (PredicateExpression is MethodCallExpression methodCallExpression)
        {
            if (methodCallExpression.Method.Name == "Like")
            {
                var updated = methodCallExpression.Update(methodCallExpression.Object, new[] { methodCallExpression.Arguments[0], methodCallExpression.Arguments[1], expression });
                UpdateExpression(updated);
            }
            if (methodCallExpression.Method.Name == "Contains")
            {
                var updated = methodCallExpression.Update(methodCallExpression.Object, new[] { expression, methodCallExpression.Arguments[1] });
                UpdateExpression(updated);
            }
        }
    }

    private void OnOperatorChanged(Expression expression)
    {
        UpdateExpression(expression);
    }

    private void UpdateExpression(Expression expression)
    {
        PredicateExpression = expression;
        OnChange(expression);
        StateHasChanged();
    }

    private void Add(ExpressionType binaryExpressionType)
    {
        var memberAccess = Expression.MakeMemberAccess(ParameterExpression, ParameterExpression.Type.GetProperties().First());

        var addedExpressionOperator = RelationalOperators
            .GetOperators(memberAccess.Type)
            .OfType<BinaryOperator>()
            .First();

        var addedExpressionConstant = Expression.Constant(memberAccess.Type.GetDefaultValue(), memberAccess.Type);
        var addedExpression = Expression.MakeBinary(addedExpressionOperator.ExpressionType, memberAccess, addedExpressionConstant);

        var newLogicalExpression = Expression.MakeBinary(
            binaryExpressionType,
            PredicateExpression.Copy(),
            addedExpression);

        OnChange(newLogicalExpression);
    }

    private void Remove()
    {
        OnRemove();
    }
}