@using System.Linq.Expressions
@using System.Reflection
@using BlazorQueryBuilder.ExpressionVisitors.Extensions
@using BlazoryQueryBuilder.Shared.Extensions
@using BlazoryQueryBuilder.Shared.Services
@using BlazoryQueryBuilder.Shared.Util
@inject PredicateFactory PredicateFactory;

<MudStack Row>
    <MudSelect Label="Field" T="string" ValueChanged="OnMemberAccessChange" Value="_selectedPropertyName">
        @foreach (PropertyInfo property in _entityType.GetProperties())
        {
            <MudSelectItem Value="@property.Name" style="@(@property.PropertyType.IsClass ? "font-weight: bold" : "")">
                @property.Name.ToString()
            </MudSelectItem>
        }
    </MudSelect>
    <RelationalOperators OnChange="@OnOperatorChanged" ExpressionType="@Binary.NodeType"></RelationalOperators>
    @switch (Type.GetTypeCode(Binary.Left.Type))
    {
        case TypeCode.Int32 when Binary.Right is ConstantExpression intConstant:
            <MudTextField Label="Value" T="int" Value="@((int)intConstant.Value)" ValueChanged="@OnValueChanged" />
            break;
        case TypeCode.String when Binary.Right is ConstantExpression stringConstant:
            <MudTextField Label="Value" T="string" Value="@(stringConstant.Value?.ToString())" ValueChanged="@OnValueChanged" />
            break;
        case TypeCode.Boolean when Binary.Right is ConstantExpression boolConstant:
            <MudCheckBox Label="Value" T="bool" Value="@((bool)boolConstant.Value)" ValueChanged="@OnValueChanged" />
            break;
        case TypeCode.DateTime when Binary.Right is NewExpression newDateTime:
            <MudDatePicker Label="Value" Date="@(new DateTime((long)((ConstantExpression)newDateTime.Arguments[0]).Value))" DateChanged="@OnValueChanged" />
            break;
    }
    <MudStack Row Spacing="2">
        <MudButton Variant="Variant.Filled" OnClick="@(() => Add(ExpressionType.AndAlso))">And</MudButton>
        <MudButton Variant="Variant.Filled" OnClick="@(() => Add(ExpressionType.OrElse))">Or</MudButton>
        <MudButton Variant="Variant.Filled" OnClick="Remove">Remove</MudButton>
    </MudStack>
</MudStack>

@code {
    MemberExpression Member => (MemberExpression)Binary.Left;
    private Type _entityType;
    private string _selectedPropertyName;

    [Parameter]
    public Action<BinaryExpression> OnChange { get; set; }

    [Parameter]
    public Action OnRemove { get; set; }

    [Parameter]
    public ParameterExpression Parameter { get; set; }

    [Parameter]
    public BinaryExpression Binary { get; set; }

    protected override void OnInitialized()
    {
        _entityType = Member.Member.DeclaringType;
        _selectedPropertyName = Member.Member.Name;
        base.OnInitialized();
    }

    private void OnMemberAccessChange(string entityPropertyName)
    {
        _selectedPropertyName = entityPropertyName;
        var entityProperty = _entityType.GetProperty(entityPropertyName);

        MemberExpression newMemberExpression;

        if (entityProperty.PropertyType.IsClass && entityProperty.PropertyType != typeof(string))
        {
            var classMember = Member.ChangePropertyAccess(_entityType, entityPropertyName);

            _entityType = classMember.Type;

            entityProperty = classMember.Type.GetProperties().First();

            newMemberExpression = Expression.MakeMemberAccess(
                classMember,
                classMember.Type.GetProperties().First());
        }
        else
        {
            newMemberExpression = Member.ChangePropertyAccess(_entityType, entityPropertyName);
        }

        Expression rightExpression = entityProperty.PropertyType switch
        {
            Type type when Type.GetTypeCode(type) 
                is TypeCode.Int32 
                or TypeCode.String 
                or TypeCode.Boolean => Expression.Constant(entityProperty.PropertyType.GetDefaultValue(), entityProperty.PropertyType),
            Type type when Type.GetTypeCode(type) 
                is TypeCode.DateTime => DateTimeExpression.New(DateTime.UtcNow),
            _ => null
        };

        if (rightExpression != null)
        {
            UpdateExpression(Expression.MakeBinary(Binary.NodeType, newMemberExpression, rightExpression));
        }
    }

    private void OnValueChanged(int intValue) => UpdateConstantExpression(intValue);

    private void OnValueChanged(string stringValue) => UpdateConstantExpression(stringValue);

    private void OnValueChanged(bool boolValue) => UpdateConstantExpression(boolValue);

    private void OnValueChanged(DateTime? dateTime)
    {
        if (dateTime.HasValue)
        {
            UpdateBinaryRightExpression(DateTimeExpression.New(dateTime.Value));
        }
    }

    private void UpdateConstantExpression<T>(T value) => UpdateBinaryRightExpression(Expression.Constant(value, typeof(T)));

    private void UpdateBinaryRightExpression(Expression expression)
    {
        var newBinaryExpression = Binary.ReplaceRight(expression);
        UpdateExpression(newBinaryExpression);
    }

    private void OnOperatorChanged(ExpressionType expressionType)
    {
        var newRelational = Binary.ReplaceType(expressionType);
        UpdateExpression(newRelational);
    }

    private void UpdateExpression(BinaryExpression newBinary)
    {
        OnChange(newBinary);
        StateHasChanged();
    }

    private void Add(ExpressionType expressionType)
    {
        var newMemberAccess = Expression.MakeMemberAccess(Parameter, Parameter.Type.GetProperties().First());
        var newConstant = Expression.Constant(newMemberAccess.Type.GetDefaultValue(), newMemberAccess.Type);
        var newRight = Expression.MakeBinary(Binary.NodeType, newMemberAccess, newConstant);

        var newBinary = Expression.MakeBinary(
            expressionType,
            Binary.Copy(),
            newRight);

        OnChange(newBinary);
    }

    private void Remove()
    {
        OnRemove();
    }

}