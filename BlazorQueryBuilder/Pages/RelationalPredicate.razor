@using System.Linq.Expressions
@using System.Reflection
@using BlazorQueryBuilder.ExpressionVisitors.Extensions
@using BlazoryQueryBuilder.Shared.Extensions
@using BlazoryQueryBuilder.Shared.Services
@using BlazoryQueryBuilder.Shared.Util

<MudStack Row>
    <MudSelect Label="Field" T="string" ValueChanged="OnFieldChanged" Value="_selectedPropertyName">
        @foreach (PropertyInfo property in _selectedPropertyType.GetProperties())
        {
            <MudSelectItem Value="@property.Name" style="@(@property.PropertyType.IsClass ? "font-weight: bold" : "")">
                @property.Name.ToString()
            </MudSelectItem>
        }
    </MudSelect>
    <RelationalOperators @ref="_relationalOperators" OnChange="@OnOperatorChanged" ExpressionType="@PredicateExpression.NodeType" OperandType="PredicateExpression.Left.Type"></RelationalOperators>
    @switch (PredicateExpression.Left.Type)
    {
        case Type intType when intType == typeof(int) && PredicateExpression.Right is ConstantExpression intConstant:
            <MudTextField Label="Value" T="int" Value="@((int)intConstant.Value)" ValueChanged="@OnValueChanged" />
            break;
        case Type stringType when stringType == typeof(string) && PredicateExpression.Right is ConstantExpression stringConstant:
            <MudTextField Label="Value" T="string" Value="@(stringConstant.Value?.ToString())" ValueChanged="@OnValueChanged" />
            break;
        case Type boolType when boolType == typeof(bool) && PredicateExpression.Right is ConstantExpression boolConstant:
            <MudCheckBox Label="Value" T="bool" Value="@((bool)boolConstant.Value)" ValueChanged="@OnValueChanged" />
            break;
        case Type dateTimeType when dateTimeType == typeof(DateTime) && PredicateExpression.Right is NewExpression newDateTime:
            <MudDatePicker Label="Value" Date="@(new DateTime((long)((ConstantExpression)newDateTime.Arguments[0]).Value))" DateChanged="@OnValueChanged" />
            break;
    }
    <MudStack Row Spacing="2">
        <MudButton Variant="Variant.Filled" OnClick="@(() => Add(ExpressionType.AndAlso))">And</MudButton>
        <MudButton Variant="Variant.Filled" OnClick="@(() => Add(ExpressionType.OrElse))">Or</MudButton>
        <MudButton Variant="Variant.Filled" OnClick="Remove">Remove</MudButton>
    </MudStack>
</MudStack>

@code {
    [Parameter]
    public Action<BinaryExpression> OnChange { get; set; }

    [Parameter]
    public Action OnRemove { get; set; }

    [Parameter]
    public ParameterExpression Parameter { get; set; }

    [Parameter]
    public BinaryExpression PredicateExpression { get; set; }

    private RelationalOperators _relationalOperators;
    private Type _selectedPropertyType;
    private string _selectedPropertyName;

    protected override void OnInitialized()
    {
        var leftOperand = (MemberExpression)PredicateExpression.Left;
        _selectedPropertyType = leftOperand.Member.DeclaringType;
        _selectedPropertyName = leftOperand.Member.Name;
        base.OnInitialized();
    }

    private void OnFieldChanged(string propertyName)
    {
        var leftOperand = (MemberExpression)PredicateExpression.Left;
        _selectedPropertyName = propertyName;
        var property = _selectedPropertyType.GetProperty(propertyName);


        // Navigation properties
        if (property.PropertyType.IsClass && property.PropertyType != typeof(string))
        {
            var navigationProperty = leftOperand.ChangePropertyAccess(_selectedPropertyType, propertyName);

            _selectedPropertyType = navigationProperty.Type;

            property = navigationProperty.Type.GetProperties().First();

            leftOperand = Expression.MakeMemberAccess(
                navigationProperty,
                navigationProperty.Type.GetProperties().First());
        }
        // Simple properties
        else
        {
            leftOperand = leftOperand.ChangePropertyAccess(_selectedPropertyType, propertyName);
        }

        Expression rightOperand = property.PropertyType switch
        {
            Type type when 
                type == typeof(int)
                || type == typeof(long)
                || type == typeof(string)
                || type == typeof(bool) => Expression.Constant(property.PropertyType.GetDefaultValue(), property.PropertyType),
            Type type when
                type == typeof(DateTime) => DateTimeExpression.New(DateTime.UtcNow),
            _ => throw new Exception("Unsupported property type")
        };

        _relationalOperators.SetOperand(property.PropertyType);
        UpdateExpression(Expression.MakeBinary(_relationalOperators.ExpressionType, leftOperand, rightOperand));
    }

    private void OnValueChanged(int intValue) => UpdateRightOperandConstant(intValue);

    private void OnValueChanged(string stringValue) => UpdateRightOperandConstant(stringValue);

    private void OnValueChanged(bool boolValue) => UpdateRightOperandConstant(boolValue);

    private void OnValueChanged(DateTime? dateTime)
    {
        if (dateTime.HasValue)
        {
            UpdateRightOperand(DateTimeExpression.New(dateTime.Value));
        }
    }

    private void UpdateRightOperandConstant<T>(T value) => UpdateRightOperand(Expression.Constant(value, typeof(T)));

    private void UpdateRightOperand(Expression expression) => UpdateExpression(PredicateExpression.ReplaceRight(expression));

    private void OnOperatorChanged(ExpressionType expressionType) => UpdateExpression(PredicateExpression.ReplaceType(expressionType));

    private void UpdateExpression(BinaryExpression expression)
    {
        PredicateExpression = expression;
        OnChange(expression);
        StateHasChanged();
    }

    private void Add(ExpressionType expressionType)
    {
        var leftOperand = Expression.MakeMemberAccess(Parameter, Parameter.Type.GetProperties().First());
        
        var rightOperandConstant = Expression.Constant(leftOperand.Type.GetDefaultValue(), leftOperand.Type);
        var rightOperand = Expression.MakeBinary(PredicateExpression.NodeType, leftOperand, rightOperandConstant);

        var expression = Expression.MakeBinary(
            expressionType,
            PredicateExpression.Copy(),
            rightOperand);

        OnChange(expression);
    }

    private void Remove()
    {
        OnRemove();
    }
}